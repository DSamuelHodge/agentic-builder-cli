# restack-gen 0.1.0
# Date: 2025-11-10
# Timestamp: 2025-11-10T10:38:06.925606
from pathlib import Path
import json
from .base import Command
from ..constants import Language, VERSION
from ..core.project import ProjectStructure
from ..core.templates import TemplateEngine, build_template_context
from ..core.validation import Validator
from ..utils.console import print_error, print_success, print_warning
from ..utils.text import snake_case, pascal_case
from ..utils.toml import TOMLLoader


class NewCommand(Command):
    """Create a new Restack app."""

    def execute(self, args: list[str]) -> int:
        import shutil

        if len(args) < 1:
            print_error("App name required")
            print("Usage: restack-gen new <app_name> [options]")
            return 1
        app_name = args[0]
        if not self._validate_app_name(app_name):
            return 1
        app_dir = self._get_app_directory(app_name)
        if app_dir.exists():
            print_error(
                f"Directory already exists: {app_dir}",
                hint="Choose a different name or remove the existing directory",
            )
            return 1
        if self.config.dry_run:
            self._show_dry_run(app_dir)
            return 0
        try:
            return self._create_app(app_name, app_dir)
        except Exception as e:
            print_error(f"Failed to create app: {e}")
            # Error recovery: cleanup partial output
            if app_dir.exists():
                try:
                    shutil.rmtree(app_dir, ignore_errors=True)
                    print_warning(f"Cleaned up partial output: {app_dir}")
                except Exception as cleanup_err:
                    print_warning(f"Failed to clean up {app_dir}: {cleanup_err}")
            if self.config.verbose:
                import traceback

                traceback.print_exc()
            return 1

    def _validate_app_name(self, app_name: str) -> bool:
        """Validate application name."""
        is_valid, error = Validator.validate_name(app_name)
        if not is_valid:
            print_error(f"Invalid app name: {error}")
        return is_valid

    def _get_app_directory(self, app_name: str) -> Path:
        """Get application directory path."""
        base_dir = self.config.cwd or Path.cwd()
        return base_dir / app_name

    def _show_dry_run(self, app_dir: Path):
        """Show what would be created in dry-run mode."""
        self.dry_run_log(f"Would create directory: {app_dir}")
        self.dry_run_log("Would create project structure")
        self.dry_run_log("Would generate sample files")

    def _create_app(self, app_name: str, app_dir: Path) -> int:
        """Create the application."""
        project = ProjectStructure(app_dir)
        project.ensure_structure()
        self.log(f"Created directory structure at {app_dir}", "success")
        lang = self.config.lang or Language.PYTHON
        engine, toml_values = self._setup_templates(app_name, app_dir, lang)
        self._create_readme(app_dir, app_name)
        self._generate_samples(engine, project, app_name, lang, toml_values)
        self._generate_test_sample(engine, project, app_name, lang, toml_values)
        # --- BEGIN: Write tsconfig.json for TypeScript projects ---
        if lang == Language.TYPESCRIPT:
            import datetime

            template_name = "tsconfig.json.j2"
            context = {
                "project_name": app_name,
                "description": f"Generated by restack-gen v{VERSION}",
                "lang": lang.value,
                "date": datetime.date.today().isoformat(),
                "generator_version": VERSION,
                "timestamp": datetime.datetime.now().isoformat(),
            }
            if engine.template_exists(template_name):
                content = engine.render(template_name, context)
                tsconfig_path = app_dir / "tsconfig.json"
                with open(tsconfig_path, "w", encoding="utf-8") as f:
                    f.write(content)
                self.log(f"Generated tsconfig.json: {tsconfig_path.name}")
            else:
                print_warning(
                    "tsconfig.json.j2 template not found for TypeScript project."
                )
        # --- END: Write tsconfig.json for TypeScript projects ---
        # --- BEGIN: Write pyproject.toml for Python projects ---
        if lang == Language.PYTHON:
            import datetime

            template_name = "pyproject.toml.j2"
            context = {
                "project_name": app_name,
                "description": f"Generated by restack-gen v{VERSION}",
                "lang": lang.value,
                "date": datetime.date.today().isoformat(),
                "generator_version": VERSION,
                "timestamp": datetime.datetime.now().isoformat(),
            }
            if engine.template_exists(template_name):
                content = engine.render(template_name, context)
                pyproject_path = app_dir / "pyproject.toml"
                with open(pyproject_path, "w", encoding="utf-8") as f:
                    f.write(content)
                self.log(f"Generated pyproject.toml: {pyproject_path.name}")
            else:
                print_warning(
                    "pyproject.toml.j2 template not found for Python project."
                )
        # --- END: Write pyproject.toml for Python projects ---
        self._create_service(app_dir, app_name)
        self._create_run_script(project.scripts_dir)
        self._show_next_steps(app_name)
        return 0

    def _setup_templates(
        self, app_name: str, app_dir: Path, lang: Language
    ) -> tuple[TemplateEngine, dict]:
        """Setup template engine and load TOML config."""
        templates_root = Path(__file__).parent.parent.parent / "templates"
        template_dir = templates_root / lang.value
        if not template_dir.exists():
            print_warning(f"No templates found for {lang.value}, using minimal setup")
            template_dir = templates_root
        engine = TemplateEngine(template_dir)
        toml_values = self._load_toml_config(templates_root, app_name, app_dir)
        return engine, toml_values

    def _load_toml_config(
        self, templates_root: Path, app_name: str, app_dir: Path
    ) -> dict:
        """Load and parse TOML configuration."""
        toml_values = {}
        toml_template = templates_root / "restack.toml.j2"
        if not toml_template.exists():
            return toml_values
        try:
            from jinja2 import Environment, FileSystemLoader

            env = Environment(loader=FileSystemLoader(str(templates_root)))
            template = env.get_template("restack.toml.j2")
            output = template.render({"app_name": app_name})
            with open(app_dir / "restack.toml", "w", encoding="utf-8") as f:
                f.write(output)
            if TOMLLoader.is_available():
                data = TOMLLoader.load(app_dir / "restack.toml")
                toml_values = self._extract_toml_values(data)
        except Exception as e:
            if self.config.verbose:
                print_warning(f"Could not parse TOML: {e}")
        return toml_values

    def _extract_toml_values(self, data: dict) -> dict:
        """Extract values from parsed TOML data."""
        toml_values = {}
        # Extract timeouts
        timeouts = data.get("timeouts", {})
        start_to_close = timeouts.get("start_to_close")
        if isinstance(start_to_close, int):
            toml_values["timeouts_start_to_close_seconds"] = start_to_close
            toml_values["timeouts_start_to_close"] = f"{start_to_close}s"
        elif isinstance(start_to_close, str):
            toml_values["timeouts_start_to_close"] = start_to_close
        # Extract retry policies
        retry = data.get("retry_policies", {})
        toml_values["retry_policies_default_json"] = json.dumps(retry)
        # Extract queues
        queues = data.get("queues", {})
        toml_values["queues_default"] = queues.get("default", "default")
        return toml_values

    def _create_readme(self, app_dir: Path, app_name: str):
        """Create README file using Jinja2 template if available."""
        from ..core.templates import TemplateEngine
        import datetime

        lang = self.config.lang or Language.PYTHON
        templates_root = Path(__file__).parent.parent.parent / "templates"
        template_dir = templates_root / lang.value
        engine = TemplateEngine(template_dir)
        template_name = "README.md.j2"
        context = {
            "project_name": app_name,
            "package_name": app_name.replace("-", "_"),
            "description": f"Generated by restack-gen v{VERSION}",
            "lang": lang.value,
            "date": datetime.date.today().isoformat(),
            "generator_version": VERSION,
            "timestamp": datetime.datetime.now().isoformat(),
        }
        readme_path = app_dir / "README.md"
        readme_path.parent.mkdir(parents=True, exist_ok=True)
        if engine.template_exists(template_name):
            content = engine.render(template_name, context)
        else:
            # fallback to minimal README
            content = f"# {app_name}\n\nGenerated by restack-gen v{VERSION}\n"
        with open(readme_path, "w", encoding="utf-8") as f:
            f.write(content)

    def _generate_samples(
        self,
        engine: TemplateEngine,
        project: ProjectStructure,
        app_name: str,
        lang: Language,
        toml_values: dict,
    ):
        """Generate sample agent, function, and workflow."""
        ext = lang.value
        samples = [
            (
                "agent",
                f"agent.{ext}.j2",
                project.get_subdir("agents") / f"{snake_case(app_name)}.{ext}",
                app_name,
            ),
            (
                "function",
                f"function.{ext}.j2",
                project.get_subdir("functions") / f"llm_chat.{ext}",
                "llm_chat",
            ),
            (
                "workflow",
                f"workflow.{ext}.j2",
                project.get_subdir("workflows") / f"automated_workflow.{ext}",
                "automated_workflow",
            ),
        ]
        for sample_type, template_name, output_path, entity_name in samples:
            if engine.template_exists(template_name):
                try:
                    context = build_template_context(
                        entity_name, app_name=app_name, **toml_values
                    )
                    content = engine.render(template_name, context)
                    with open(output_path, "w", encoding="utf-8") as f:
                        f.write(content)
                    self.log(f"Generated sample {sample_type}: {output_path.name}")
                except Exception as e:
                    print_warning(f"Could not generate sample {sample_type}: {e}")

    def _generate_test_sample(
        self,
        engine: TemplateEngine,
        project: ProjectStructure,
        app_name: str,
        lang: Language,
        toml_values: dict,
    ):
        """Generate sample test file."""
        ext = lang.value
        template_name = f"test_sample.{ext}.j2"
        output_path = project.tests_dir / f"test_sample.{ext}"
        if engine.template_exists(template_name):
            try:
                context = build_template_context(
                    "sample", app_name=app_name, project_name=app_name, **toml_values
                )
                content = engine.render(template_name, context)
                with open(output_path, "w", encoding="utf-8") as f:
                    f.write(content)
                self.log(f"Generated sample test: {output_path.name}")
            except Exception as e:
                print_warning(f"Could not generate sample test: {e}")

    def _create_service(self, app_dir: Path, app_name: str):
        """Create service.py registrar."""
        service_code = f"""from restack_ai import Restack
from src.agents.{snake_case(app_name)} import {pascal_case(app_name)}
from src.functions.llm_chat import llm_chat
from src.workflows.automated_workflow import AutomatedWorkflow

client = Restack()

async def main():
	await client.start_service(
		agents=[{pascal_case(app_name)}],
		workflows=[AutomatedWorkflow],
		functions=[llm_chat]
	)

if __name__ == '__main__':
	import asyncio
	asyncio.run(main())
"""
        with open(app_dir / "service.py", "w", encoding="utf-8") as f:
            f.write(service_code)

    def _create_run_script(self, scripts_dir: Path):
        """Create run_engine.sh script."""
        script_content = """#!/usr/bin/env bash
set -e

echo "Starting Restack engine..."
# Add your engine start command here
# docker-compose up -d
# or
# restack-engine start
"""
        script_path = scripts_dir / "run_engine.sh"
        with open(script_path, "w", encoding="utf-8") as f:
            f.write(script_content)
        try:
            script_path.chmod(0o755)
        except Exception:
            pass

    def _show_next_steps(self, app_name: str):
        """Show next steps to user."""
        print_success(f"Created new Restack app: {app_name}")
        print()
        print("Next steps:")
        print(f"  cd {app_name}")
        print("  pip install -e .[dev]")
        print("  restack-gen dev")
